// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"strings"
)

const pre = `// Code generated by go run rng_gen.go; DO NOT EDIT.
package rng
`

const _struct = `
type %s struct {
	start, end     %s
	startex, endex bool // exclude start or end

	// If empty is true, the range must be empty. If not, we need to check it.
	empty bool
}
`

const _new = `
func New%s(start, end %s, startex, endex bool) *%s {
	return &%s{
		start:   start,
		end:     end,
		startex: startex,
		endex:   endex,
	}
}
`

const _getter = `
func (r *%s) Start() %s  { return r.start }
func (r *%s) End() %s    { return r.end }
func (r *%s) Startex() bool { return r.startex }
func (r *%s) Endex() bool   { return r.endex }
`

const _IsEmptyAndIn = `
func (r *%s) IsEmpty() bool {
	if r.empty {
		return true
	}
	if r.start > r.end || r.start == r.end && (r.startex || r.endex) {
		r.empty = true
		return true
	}
	return false
}

func (r *%s) In(x %s) bool {
	if r.IsEmpty() {
		return false
	}
	if r.start > x || r.startex && r.start == x {
		return false
	}
	if r.end < x || r.endex && r.end == x {
		return false
	}
	return true
}
`

const _InterAndUnion = `
func %sInter(x, y *%s) *%s {
	r := &%s{}

	if x.IsEmpty() || y.IsEmpty() || x.end < y.start || x.start > y.end {
		r.empty = true
		return r
	}

	if x.start < y.start {
		r.start = y.start
		r.startex = y.startex
	} else if x.start == y.start {
		r.start = x.start
		r.startex = x.startex || y.startex
	} else {
		r.start = x.start
		r.startex = x.startex
	}

	if x.end < y.end {
		r.end = x.end
		r.endex = x.endex
	} else if x.end == y.end {
		r.end = x.end
		r.endex = x.endex || y.endex
	} else {
		r.end = y.end
		r.endex = y.endex
	}

	return r
}

func %sUnion(x, y *%s) *%s {
	r := &%s{}

	if x.IsEmpty() {
		r.start, r.startex, r.end, r.endex, r.empty = x.start, x.startex, x.end, x.endex, x.empty
		return r
	}

	if y.IsEmpty() {
		r.start, r.startex, r.end, r.endex, r.empty = y.start, y.startex, y.end, y.endex, y.empty
		return r
	}

	if x.start < y.start {
		r.start = x.start
		r.startex = x.startex
	} else if x.start == y.start {
		r.start = x.start
		r.startex = x.startex && y.startex
	} else {
		r.start = y.start
		r.startex = y.startex
	}

	if x.end < y.end {
		r.end = y.end
		r.endex = y.endex
	} else if x.end == y.end {
		r.end = x.end
		r.endex = x.endex && y.endex
	} else {
		r.end = x.end
		r.endex = x.endex
	}

	return r
}
`

func main() {
	alltypes := []string{"Int", "Int8", "Int16", "Int32", "Int64",
		"Uint", "Uint8", "Uint16", "Uint32", "Uint64",
		"Float32", "Float64"}
	w := new(bytes.Buffer)
	w.WriteString(pre)
	for _, utype := range alltypes {
		ltype := strings.ToLower(utype)
		fmt.Fprintf(w, _struct, utype, ltype)
		fmt.Fprintf(w, _new, utype, ltype, utype, utype)
		fmt.Fprintf(w, _getter, utype, ltype, utype, ltype, utype, utype)
		fmt.Fprintf(w, _IsEmptyAndIn, utype, utype, ltype)
		fmt.Fprintf(w, _InterAndUnion, utype, utype, utype, utype, utype, utype, utype, utype)
	}

	out, err := format.Source(w.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := ioutil.WriteFile("rng.go", out, 0660); err != nil {
		log.Fatal(err)
	}
}
